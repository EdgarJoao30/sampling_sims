---
title: "spatial"
format: dashboard
server: shiny
---


```{r, include = FALSE}
#| context: server

library(INLA)
library(inlabru)
library(fmesher)
library(sf)
library(terra)
library(tidyverse)
library(tidyterra)
library(stars)
library(raster)

wd <- '~/OneDrive - University of Glasgow/PhD/0_simulations'
boundary <- st_read(paste0(wd, '/data/20240312_ROI_4326.shp')) |> 
  st_union() |> 
  st_transform(crs = 32650)
boundary_sp <- as(boundary, "Spatial")
# Land cover
landcover <- rast(paste0(wd, '/data/Landcover_AllClass.tif')) %>% project(crs(boundary)) %>% raster::crop(boundary)
boundary_extent <- extent(boundary_sp)
empty_raster <- raster(boundary_extent, res = 500, crs = crs(boundary_sp))
aligned_landcover <- terra::resample(landcover, rast(empty_raster), method = "near")
mask <- rasterize(vect(boundary), aligned_landcover)
hab_mask <- terra::mask(aligned_landcover, mask)
hab_mask <- hab_mask %>% filter(Landcover_AllClass < 99)
hab_mask <- round(hab_mask)
df <- as.data.frame(hab_mask, xy=T)
df$class <- factor(df$Landcover_AllClass)
df$class <- plyr::revalue(df$class, c("0"="Oil", "1"="Secondary", "2"="Primary", "3"="Plantation", "4"="Built"))
df$class <- relevel(factor(df$class), ref = "Primary")
df_sf <- st_as_sf(df, coords = c('x', 'y'), crs = 32650)

sampling_points <- st_read(paste0(wd, '/data/20250129_points_sampling_scenarios_nobuffer.geojson'))
sampling_grids <- st_read(paste0(wd, '/data/20250129_grids_sampling_scenarios_nobuffer.geojson'))

k = 12
# rho = 0.3
beta <- c(0, 0.4567584, 1.5648494, 1.0986123, 1.8282377)
# sigma <- 0.5
# variance <- sigma^2
alpha <- 2
# range <- 1
# kappa <- sqrt(8 * (alpha - 1)) / range
# theta <- c(-0.5 * log(4 * pi * variance * kappa^2), log(kappa))
seed <- 1234

simple_mesh <- reactive({
    max_edge <- input$mx_edge
    coff <- input$coff
    mesh <- fm_mesh_2d(df_sf, max.edge = as.numeric(max_edge), cutoff = as.numeric(coff))
    mesh
  })

spatial_field <- reactive({
  rho <- input$rho
  sigma <- input$sigma
  range <- input$range
  ar_type <- input$AR
  
  variance <- sigma^2
  kappa <- sqrt(8 * (alpha - 1)) / range
  theta <- c(-0.5 * log(4 * pi * variance * kappa^2), log(kappa))
  seed <- 1234
  
  boundary_sp <- as(boundary, "Spatial")
  mask <- rasterize(vect(boundary), aligned_landcover)
  mesh <- simple_mesh()
  spde <- inla.spde2.matern(mesh, alpha = alpha)
  Q <- inla.spde2.precision(spde, theta = theta)
  
  true_field <- inla.qsample(k, Q, seed = seed)
  df_sf$field <- fm_evaluate(mesh, loc = df_sf, field = true_field)
  
  # df_sf$field_AR1 <- df_sf$field 
  
  if (ar_type == 'Option 1') {
    df_sf$field_AR1 <- df_sf$field 
    for (j in 2:k) {
       df_sf$field_AR1[, j] <- rho * df_sf$field_AR1[, j - 1] + sqrt(1 - rho^2) * df_sf$field[, j]  
    }
  } else if (ar_type == 'Option 2') {
    df_sf$field_AR1 <- df_sf$field / sqrt(1 - rho^2) 
    for (j in 2:k) {
       df_sf$field_AR1[, j] <- rho * df_sf$field_AR1[, j - 1] + df_sf$field[, j] / sqrt(1 - rho^2) 
    }
  } else if (ar_type == 'ARIMA') {
    df_sf$field_AR1 <- df_sf$field 
    for (i in 1:nrow(df_sf)) {
       arima_values <- arima.sim(model = list(ar = 0.3), n = 12)
       df_sf$field_AR1[i, ] <- df_sf$field_AR1[i, ] + arima_values
    }
  }
  
  # for (j in 2:k) {
  #   df_sf$field_AR1[, j] <- rho * df_sf$field_AR1[, j - 1] + sqrt(1 - rho^2) * df_sf$field[, j]  
  # }
  
  df_sf
})

sim <- reactive({
    sp_field <- spatial_field()
    ccov <- factor(replicate(12, sp_field$class))
    n <- nrow(df)
    sd.mu <- 0.001
    mu <- beta[unclass(ccov)] + sp_field$field_AR1 + rnorm(n * k, 0, sd.mu)
    sp_field$mu <- exp(mu)
    generate_nbinomial <- function(x) {
      rnbinom(mu= x, n=1, size=10) #### FLAG 2 - Change to poisson, to prevent competition with previous terms
    }
    nbinomial_sample <- apply(sp_field$mu, c(1, 2), generate_nbinomial)
    sp_field$mosq <- nbinomial_sample
    #sp_field$mosq[is.na(sp_field$mosq)] <- 0 # SEE WHY THE NAs... SOLVED
    sp_field
  })

output$meshplot <- renderPlot({
  mesh <- simple_mesh()
  ggplot() +
    geom_fm(data = mesh)
})

output$lcplot <- renderPlot({
  ggplot() +
    geom_spatraster(data = as.factor(hab_mask)) +
    scale_fill_manual(values = c('#9fa86a', 'green', 'darkgreen', '#def016', 'gray')) +
    ggtitle('Land cover')+
    labs(fill = 'Value', x='', y='')+
    theme_minimal()+
    theme(axis.text.x = element_blank(), axis.text.y = element_blank())
})

output$grfplot <- renderPlot({
  month <- input$month
  gf <- spatial_field()
  ggplot() +
    gg(gf, aes(fill = field_AR1[,month]), geom = "tile") +
    ggtitle('GMRF')+
    labs(fill = 'Value', x='', y='')+
    theme_minimal()+
    scale_fill_gradient(low = "white", high = "blue", limits = c(min(gf$field_AR1), max(gf$field_AR1)))+
    theme(axis.text.x = element_blank(), axis.text.y = element_blank())
})

output$simplot <- renderPlot({
  month <- input$month
  sim <- sim()
  ggplot() +
    gg(sim, aes(fill = mosq[,month]), geom = "tile") +
    ggtitle('Anopheles count')+
    labs(fill = 'Value', x='', y='')+
    theme_minimal()+
    scale_fill_gradient(low = "white", high = "red", limits = c(min(sim$mosq), max(sim$mosq)))+
    theme(axis.text.x = element_blank(), axis.text.y = element_blank())
})

sampling_g <- reactive({
  iteration2 <- as.integer(input$iteration)
  month2 <- as.integer(input$month_page2)
  sample_size2 <- as.integer(input$sample_size)
  
  samp <- sampling_grids %>% dplyr::filter(iteration == iteration2, month == month2, sample_size == sample_size2)
  samp
})

sampling_p <- reactive({
  iteration2 <- as.integer(input$iteration)
  month2 <- as.integer(input$month_page2)
  sample_size2 <- as.integer(input$sample_size)
  sampling_points %>% dplyr::filter(iteration == iteration2, month == month2, sample_size == sample_size2)
})

output$samplingplot <- renderPlot({
  
  
  sp <- sampling_p()
  sg <- sampling_g()
  
  ggplot() +
    geom_sf(data = boundary, alpha = 0.5) +
    geom_sf(data = sg) +
    geom_sf(data = sp) +
    facet_wrap(.~scenario)+
    theme_minimal()
  
  
})


autocorrelation <- reactive({
  sp <- spatial_field()
  compute_acf <- function(x, max_lag = 12) {
    acf_values <- acf(x, plot = FALSE, lag.max = max_lag)$acf
    return(acf_values)
  }
  acf_values <- apply(sp$field_AR1, 1, compute_acf)
  sd_acf <- apply(acf_values, 1, sd)
  mean_acf <- apply(acf_values, 1, mean)
  
  data <- data.frame(
    Index = 1:length(mean_acf),
    Mean = mean_acf,
    SD = sd_acf
  )
  
  data
})

output$acplot <- renderPlot({
  autocorrelation_data <- autocorrelation()
  
  ggplot(autocorrelation_data, aes(x = Index, y = Mean)) +
    geom_line(color = "blue") +
    geom_ribbon(aes(ymin = Mean - 2 * SD, ymax = Mean + 2 * SD), alpha = 0.2, fill = "blue") +
    scale_x_continuous(breaks = 1:12, labels = 0:11) + 
    labs(title = "Mean Values with Â±2 Standard Deviations", x = "Index", y = "Value") +
    theme_minimal()
})

```

# Page 1

```{r}
#| panel: sidebar
sliderInput("coff", "coff:", min = 1000, max = 10000, value = 1000)
sliderInput("mx_edge", "mx_edge:", min = 1000, max = 10000, value = c(2500, 5000))
sliderInput("range", "range:", min = 1000, max = 5000, value = 3000)
sliderInput("month", "month:", min = 1, max = 12, value = 1)
sliderInput("rho", "rho:", min = 0, max = 1, value = 0.3)
selectInput("AR", "AR", c('Option 1', 'Option 2', 'ARIMA'))
sliderInput("sigma", "sigma:", min = 0.1, max = 2, value = 0.5)
```

```{r}
#| panel: fill
#| layout: "[ [1,1], [1,1], [1] ]"

plotOutput("meshplot")
plotOutput("lcplot")

plotOutput("grfplot") 
plotOutput("simplot")

plotOutput("acplot")
```



# Page 2

```{r}
#| panel: sidebar
sliderInput("iteration", "iteration", min = 1, max = 100, value = 1)
sliderInput("month_page2", "month_page2", min = 1, max = 12, value = 1)
selectInput("sample_size", "sample_size", c(5, 10, 15), 15)
```

```{r}
#| panel: fill

plotOutput("samplingplot")
```
